
  
    
    

  

  
    
    

  

  
    
    

  

  
    
    

  

  
    
    

  

  
    
    

  

  
    
    

  

  
    
    

  

  
    
    

  


<!Doctype html>
<html id="docs" class="Imported Docs">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="/images/favicon.png">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,400italic,500,500italic,700,700italic,900,900italic">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto+Mono">
    <link rel="stylesheet" type="text/css" href="/css/styles.css"><!-- default styles.css on -->
    <link rel="stylesheet" type="text/css" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/sweetalert/1.1.3/sweetalert.min.css">
    <link rel="stylesheet" type="text/css" href="/css/callouts.css">
    <link rel="stylesheet" type="text/css" href="/css/custom-jekyll/tags.css">
    
    
    <!-- no custom css detected -->

    
    <meta name="description" content="kubeadm 设置工具参考指南" />
    

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sweetalert/1.1.3/sweetalert.min.js"></script>
    <script src="/js/script.js"></script>
    <script src="/js/custom-jekyll/tags.js"></script>
    <!-- no custom js detected -->
    <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>kubeadm 设置工具参考指南 | Kubernetes</title>
<meta name="generator" content="Jekyll v3.6.0" />
<meta property="og:title" content="kubeadm 设置工具参考指南" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Production-Grade Container Orchestration" />
<meta property="og:description" content="Production-Grade Container Orchestration" />
<link rel="canonical" href="http://0.0.0.0:4000/docs/admin/kubeadm/" />
<meta property="og:url" content="http://0.0.0.0:4000/docs/admin/kubeadm/" />
<meta property="og:site_name" content="Kubernetes" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@kubernetesio" />
<script type="application/ld+json">
{"description":"Production-Grade Container Orchestration","@type":"WebPage","url":"http://0.0.0.0:4000/docs/admin/kubeadm/","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://0.0.0.0:4000/images/favicon.png"}},"headline":"kubeadm 设置工具参考指南","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


<body>

<div id="cellophane" onclick="kub.toggleMenu()"></div>

<header>
    <a href="/" class="logo"></a>

    <div class="nav-buttons" data-auto-burger="primary">
        <ul class="global-nav">
            <li><a href="/docs/home/">Documentation</a></li>
            <li><a href="http://blog.kubernetes.io/">Blog</a></li>
            <li><a href="/partners/">Partners</a></li>
            <li><a href="/community/">Community</a></li>
            <li><a href="/case-studies/">Case Studies</a></li>
            <li>
                <a href="#">
                    v1.9 <span class="ui-icon ui-icon-carat-1-s"></span>
                </a>
                <ul>
                
                    
                    <li><a href="https://kubernetes.io/docs/admin/kubeadm/">v1.9</a></li>
                    
                
                    
                    <li><a href="https://v1-8.docs.kubernetes.io/docs/admin/kubeadm/">v1.8</a></li>
                    
                
                    
                    <li><a href="https://v1-7.docs.kubernetes.io/docs/admin/kubeadm/">v1.7</a></li>
                    
                
                    
                    <li><a href="https://v1-6.docs.kubernetes.io/docs/admin/kubeadm/">v1.6</a></li>
                    
                
                    
                    <li><a href="https://v1-5.docs.kubernetes.io/docs/admin/kubeadm/">v1.5</a></li>
                    
                
                </ul>
            </li>
        </ul>
        <!-- <a href="/docs/home" class="button" id="viewDocs" data-auto-burger-exclude>View Documentation</a> -->
        <a href="/docs/tutorials/kubernetes-basics/" class="button" id="tryKubernetes" data-auto-burger-exclude>Try Kubernetes</a>
        <button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
    </div>

    <nav id="mainNav">
        <main data-auto-burger="primary">
        <div class="nav-box">
            <h3><a href="/docs/tutorials/stateless-application/hello-minikube/">Get Started</a></h3>
            <p>Ready to get your hands dirty? Build a simple Kubernetes cluster that runs "Hello World" for Node.js.</p>
        </div>
        <div class="nav-box">
            <h3><a href="/docs/home/">Documentation</a></h3>
            <p>Learn how to use Kubernetes with the use of walkthroughs, samples, and reference documentation. You can even <a href="/editdocs/" data-auto-burger-exclude>help contribute to the docs</a>!</p>
        </div>
        <div class="nav-box">
            <h3><a href="/community/">Community</a></h3>
            <p>If you need help, you can connect with other Kubernetes users and the Kubernetes authors, attend community events, and watch video presentations from around the web.</p>
        </div>
        <div class="nav-box">
            <h3><a href="http://blog.kubernetes.io">Blog</a></h3>
            <p>Read the latest news for Kubernetes and the containers space in general, and get technical how-tos hot off the presses.</p>
        </div>
        </main>
        <main data-auto-burger="primary">
        <div class="left">
            <h5 class="github-invite">Interested in hacking on the core Kubernetes code base?</h5>
            <a href="https://github.com/kubernetes/kubernetes" class="button" data-auto-burger-exclude>View On Github</a>
        </div>

        <div class="right">
            <h5 class="github-invite">Explore the community</h5>
            <div class="social">
                <a href="https://twitter.com/kubernetesio" class="twitter"><span>Twitter</span></a>
                <a href="https://github.com/kubernetes/kubernetes" class="github"><span>Github</span></a>
                <a href="http://slack.k8s.io/" class="slack"><span>Slack</span></a>
                <a href="http://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>Stack Overflow</span></a>
                <a href="https://groups.google.com/forum/#!forum/kubernetes-users" class="mailing-list"><span>Mailing List</span></a>
                <a href="https://calendar.google.com/calendar/embed?src=nt2tcnbtbied3l6gi2h29slvc0%40group.calendar.google.com" class="calendar"><span>Events Calendar</span></a>
            </div>
        </div>
        <div class="clear" style="clear: both"></div>
        </main>
    </nav>
</header>


<!--  HERO  -->
<section id="hero" class="light-text">
  <h1>Imported Docs</h1>
  <h5>Docs imported from other Kubernetes SIGs and repos.</h5>
  <div id="vendorStrip" class="light-text">
    <ul>
      <li><a href="/docs/home/" >HOME</a></li>
      <li><a href="/docs/setup/" >SETUP</a></li>
      <li><a href="/docs/concepts/" >CONCEPTS</a></li>
      <li><a href="/docs/tasks/" >TASKS</a></li>
      <li><a href="/docs/tutorials/" >TUTORIALS</a></li>
      <li><a href="/docs/reference/" >REFERENCE</a></li>
    </ul>
    <div id="searchBox">
      <input type="text" id="search" placeholder="Search" onkeydown="if (event.keyCode==13) window.location.replace('/docs/search/?q=' + this.value)" autofocus="autofocus">
    </div>
  </div>
</section>




<section id="encyclopedia">
  <div id="docsToc">
        <div class="pi-accordion">
          
  

    

    
      <a class="item" data-title="导入的文档" href="/docs/imported/"></a>
    
  

  
    <div class="item" data-title="Community">
      <div class="container">
        
  

    

    
      <a class="item" data-title="Kubernetes Contributor Guide" href="/docs/imported/community/guide/"></a>
    
  

  

    

    
      <a class="item" data-title="Kubernetes开发者指南" href="/docs/imported/community/devel/"></a>
    
  

  

    

    
      <a class="item" data-title="Kubernetes指导计划" href="/docs/imported/community/mentoring/"></a>
    
  

  

    

    
      <a class="item" data-title="Kubernetes增强方案过程" href="/docs/imported/community/keps/"></a>
    
  


      </div>
    </div>
  


        </div> <!-- /pi-accordion -->
    <button class="push-menu-close-button" onclick="kub.toggleToc()"></button>
  </div> <!-- /docsToc -->

  <div id="docsContent">
        <p><a href="/editdocs#docs/admin/kubeadm.md" id="editPageButton">Edit This Page</a></p>

        
          <h1>kubeadm 设置工具参考指南</h1>
        

        <p>本文档提供有关如何使用 kubeadm 高级选项的信息。</p>

<p>运行 <code class="highlighter-rouge">kubeadm init</code> 引导一个 Kubernetes 集群。这包括了以下步骤：</p>

<ol>
  <li>
    <p>在进行更改之前，kubeadm 运行一系列检查以验证系统状态。一些检查只会触发警告，有些检查会被视为错误并会退出 kubeadm，直到问题得到解决或用户指定了 <code class="highlighter-rouge">--skip-preflight-checks</code>。</p>
  </li>
  <li>
    <p>kubeadm 将生成一个 token，以便其它 node 可以用来注册到 master 中。用户也可以选择自己提供一个 token。</p>
  </li>
  <li>
    <p>kubeadm 将生成一个自签名 CA 来为每个组件设置身份（包括 node）。它也生成客户端证书以便各种组件可以使用。如果用户已经提供了自己的 CA 并将其放入 cert 目录（通过 <code class="highlighter-rouge">--cert-dir</code> 配置，默认路径为 <code class="highlighter-rouge">/etc/kubernetes/pki</code>），则跳过此步骤。</p>
  </li>
  <li>
    <p>输出一个 kubeconfig 文件以便 kubelet 能够使用这个文件来连接到 API server，以及一个额外的 kubeconfig 文件以作管理用途。</p>
  </li>
  <li>
    <p>kubeadm 将会为 API server、controller manager 和 scheduler 生成 Kubernetes 的静态 Pod manifest 文件，并将这些文件放入 <code class="highlighter-rouge">/etc/kubernetes/manifests</code> 中。Kubelet 将会监控这个目录，以便在启动时创建 pod。这些都是 Kubernetes 的关键组件，一旦它们启动并正常运行后，kubeadm 就能启动和管理其它额外的组件了。</p>
  </li>
  <li>
    <p>kubeadm 将会给 master 节点 “taint” 标签，以让控制平面组件只运行在这个节点上。它还建立了 RBAC 授权系统，并创建一个特殊的 ConfigMap 用来引导与 kubelet 的互信连接。</p>
  </li>
  <li>
    <p>kubeadm 通过 API server 安装插件组件。目前这些组件有内部的 DNS server 和 kube-proxy DaemonSet。</p>
  </li>
</ol>

<p>在集群的各 node 上运行 <code class="highlighter-rouge">kubeadm join</code> 包含以下步骤：</p>

<ol>
  <li>
    <p>kubeadm 从 API server 下载根 CA 信息。它使用 token 来验证数据的真实性。</p>
  </li>
  <li>
    <p>kubeadm 创建一个本地密钥对。它准备一个证书签名请求（CSR）并将其发送到 API server 进行签名。bootstrap token 用于验证。控制平面将自动签署这个 CSR 请求。</p>
  </li>
  <li>
    <p>kubeadm 配置本地 kubelet 以连接到 API server。</p>
  </li>
</ol>

<h2 id="使用">使用</h2>

<p>支持多个值的字段要么用逗号分隔，要么多次指定这个参数。</p>

<p>kubeadm 命令行接口目前处于 <strong>beta</strong> 阶段，我们致力于不破坏 <code class="highlighter-rouge">kubeadm init</code> 和 <code class="highlighter-rouge">kubeadm join</code> 脚本的使用。但是以下的 kubeadm 配置文件可能是一个例外，因为这个文件格式目前仍然是 alpha 阶段并且很可能会发生改变。</p>

<h3 id="kubeadm-init"><code class="highlighter-rouge">kubeadm init</code></h3>

<p>通常情况下，不需要添加其它参数直接运行 <code class="highlighter-rouge">kubeadm init</code> 已经足够了，但是在一些情况下您可能想要重写默认行为。以下我们列出能够用来自定义 Kubernetes 安装的所有参数。</p>

<ul>
  <li><code class="highlighter-rouge">--apiserver-advertise-address</code></li>
</ul>

<p>这是 API server 用来告知集群中其它成员的地址，这也是在 init 流程的时候用来构建 <code class="highlighter-rouge">kubeadm join</code> 命令行的地址。如果不设置（或者设置为 0.0.0.0）那么将使用默认接口的 IP 地址。</p>

<p>该地址也被添加到 API Server 使用的证书中。</p>

<ul>
  <li><code class="highlighter-rouge">--apiserver-bind-port</code></li>
</ul>

<p>API server 将绑定的端口。默认为 6443。</p>

<ul>
  <li><code class="highlighter-rouge">--apiserver-cert-extra-sans</code></li>
</ul>

<p>一些额外的 hostname 或者 IP 地址，应添加到 API Server 将使用到的证书中的 Subject Alternate Name 章节。如果您通过负载均衡和公共 DNS 来暴露 API Server 服务，那么您可以指定如下</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--apiserver-cert-extra-sans=kubernetes.example.com,kube.example.com,10.100.245.1
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">--cert-dir</code></li>
</ul>

<p>存储证书的路径。默认为 “/etc/kubernetes/pki”。</p>

<ul>
  <li><code class="highlighter-rouge">--config</code></li>
</ul>

<p>kubeadm 指定的 <a href="#config-file">配置文件</a>。这可以用来指定一个扩展的选项集，包括传递任意命令行标志到控制平面组件。</p>

<p><strong>注意</strong>：如果使用配置文件 <em>和</em> 参数来提供配置值，那么将优先使用文件。例如，如果存在以下配置文件：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubeadm.k8s.io/v1alpha1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">MasterConfiguration</span>
<span class="na">token</span><span class="pi">:</span> <span class="s">1234</span>
</code></pre></div></div>

<p>并且用户运行了 <code class="highlighter-rouge">kubeadm init --config file.yaml --token 5678</code> 命令，那么 token 值将为 <code class="highlighter-rouge">1234</code>。</p>

<ul>
  <li><code class="highlighter-rouge">--kubernetes-version</code> (default ‘latest’) the kubernetes version to initialise</li>
</ul>

<p><strong>v1.6</strong> 版本的 kubeadm 只支持至少 <strong>v1.6.0</strong> 版本的集群构建。这有很多原因，包括 kubeadm 对 RBAC 的使用，Bootstrap Token 系统和对 Certificates API 的增强。通过这个参数您可以尝试 Kubernetes 的更新的版本。参阅 <a href="https://github.com/kubernetes/kubernetes/releases">发布页面</a> 来获得完整的可用版本列表。</p>

<ul>
  <li><code class="highlighter-rouge">--pod-network-cidr</code></li>
</ul>

<p>对于某些网络解决方案，Kubernetes master 也可以为每个节点分配网络范围（CIDR），这包括一些云提供商和 flannel。通过 <code class="highlighter-rouge">--pod-network-cidr</code> 参数指定的子网范围将被分解并发送给每个 node。这个范围应该使用最小的 /16，以让 controller-manager 能够给集群中的每个 node 分配 /24 的子网。如果您是通过 <a href="https://github.com/coreos/flannel/blob/master/Documentation/kube-flannel.yml">这个 manifest 文件</a> 来使用 flannel，那么您应该使用 <code class="highlighter-rouge">--pod-network-cidr=10.244.0.0/16</code>。大部分基于 CNI 的网络解决方案都不需要这个参数。</p>

<ul>
  <li><code class="highlighter-rouge">--service-cidr</code> (默认 ‘10.96.0.0/12’)</li>
</ul>

<p>您可以通过使用 <code class="highlighter-rouge">--service-cidr</code> 参数来覆盖 Kubernetes 用来分配 pod IP 地址的子网。如果您这么做了，那么您还需要更新 <code class="highlighter-rouge">/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code> 文件来反映这个修改，否则 DNS 将无法正常工作。</p>

<ul>
  <li><code class="highlighter-rouge">--service-dns-domain</code> (默认 ‘cluster.local’)</li>
</ul>

<p>默认情况下，<code class="highlighter-rouge">kubeadm init</code> 部署的集群会给服务分配 DNS 名称，格式为 <code class="highlighter-rouge">&lt;service_name&gt;.&lt;namespace&gt;.svc.cluster.local</code>。您可以使用 <code class="highlighter-rouge">--service-dns-domain</code> 来修改这个 DNS 名称的后缀。同样地，您也需要根据修改更新 <code class="highlighter-rouge">/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code> 文件，否则 DNS 将无法正常工作。</p>

<p><strong>注意</strong>：</p>

<ul>
  <li><code class="highlighter-rouge">--skip-preflight-checks</code></li>
</ul>

<p>默认情况下，kubeadm 在修改前会进行一系列的 preflight 检查来验证系统。如果需要的话，高级用户可以使用这个参数来跳过这些检查。</p>

<ul>
  <li><code class="highlighter-rouge">--token</code></li>
</ul>

<p>默认情况下，<code class="highlighter-rouge">kubeadm init</code> 会自动生成用来初始化每个新 node 的 token。如果您想要手动指定这个 token，您可以使用这个 <code class="highlighter-rouge">--token</code> 参数。token 的格式必须是 <code class="highlighter-rouge">[a-z0-9]{6}\.[a-z0-9]{16}</code>。可以通过 <code class="highlighter-rouge">kubeadm token generate</code> 来生成一个兼容的随机 token。集群创建后，token 也能通过 API 进行管理。参阅下面的 <a href="#manage-tokens">管理 token 章节</a>。</p>

<ul>
  <li><code class="highlighter-rouge">--token-ttl</code></li>
</ul>

<p>这个参数设置 token 的过期时间。这是从当前时间开始计算的一个持续时间。在这段时间之后，令牌将不再有效并被删除。值为 0 表示令牌永不过期。默认值是 0。参阅下面的 <a href="#manage-tokens">管理 token 章节</a>。</p>

<h3 id="kubeadm-join"><code class="highlighter-rouge">kubeadm join</code></h3>

<p>当把一个 node 添加到已初始化完毕的集群中时，我们需要建立一个双向的互信机制。这被划分为 discovery（让 Node 相信 Kubernetes master）和 TLS bootstrap（让 Kubernetes master 相信 Node）两个过程。</p>

<p>对于 discovery 有两个主要方案。第一个是使用一个共享的 token，并附带上 API server 的 IP 地址。第二个是提供一个文件（标准 kubeconfig 文件的子集），这个文件可以使一个本地文件或者是通过 HTTPS URL 下载的文件。格式是 <code class="highlighter-rouge">kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443</code>，<code class="highlighter-rouge">kubeadm join --discovery-file path/to/file.conf</code> 或者 <code class="highlighter-rouge">kubeadm join --discovery-file https://url/file.conf</code>。只能使用一种格式。一旦从 URL 加载了 discovery 信息，则必须使用 HTTPS 并且安装了 CA bundle 的主机将被用来验证连接。</p>

<p>TLS bootstrap 机制也是通过共享 token 来驱动的。这用于临时向 Kubernetes 主机进行身份验证，以提交本地创建的密钥对的证书签名请求（CSR）。默认情况下，kubeadm 将设置 Kubernetes master 自动批准这些签名请求。这个 token 是通过 <code class="highlighter-rouge">--tls-bootstrap-token abcdef.1234567890abcdef</code> 参数传入的。</p>

<p>多数情况下两者使用的都是同样的 token。这种情况下，可以使用 <code class="highlighter-rouge">--token</code> 参数，而不用分别指定每个 token。</p>

<p>以下是一个如何使用的示例：</p>

<p><code class="highlighter-rouge">kubeadm join --token=abcdef.1234567890abcdef 192.168.1.1:6443</code></p>

<p>特定选项：</p>

<ul>
  <li><code class="highlighter-rouge">--config</code></li>
</ul>

<p>扩展在 <a href="#config-file">kubeadm 特定配置文件</a> 中的选项。</p>

<ul>
  <li><code class="highlighter-rouge">--skip-preflight-checks</code></li>
</ul>

<p>默认情况下，kubeadm 在修改前会进行一系列的 preflight 检查来验证系统。如果需要的话，高级用户可以使用这个参数来跳过这些检查。</p>

<ul>
  <li><code class="highlighter-rouge">--discovery-file</code></li>
</ul>

<p>一个本地文件或者 HTTPS URL。指定的文件必须是一个 kubeconfig 文件，文件只能包含一个未命名的集群条目。这用来找到将要加入的 API server 的地址以及在与 server 交互时需要使用的根 CA bundle。</p>

<p>这可能看起来像这样：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">clusters</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">cluster</span><span class="pi">:</span>
    <span class="na">certificate-authority-data</span><span class="pi">:</span> <span class="s">&lt;really long certificate data&gt;</span>
    <span class="na">server</span><span class="pi">:</span> <span class="s">https://10.138.0.2:6443</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
<span class="na">contexts</span><span class="pi">:</span> <span class="pi">[]</span>
<span class="na">current-context</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Config</span>
<span class="na">preferences</span><span class="pi">:</span> <span class="pi">{}</span>
<span class="na">users</span><span class="pi">:</span> <span class="pi">[]</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">--discovery-token</code></li>
</ul>

<p>discovery token 要配合 API server 的地址（作为一个未命名参数）一起使用，以下载并且验证集群信息。集群信息的关键部分是根 CA bundle，其用来在后续的 TLS 连接中验证 server 的身份信息。</p>

<ul>
  <li><code class="highlighter-rouge">--tls-bootstrap-token</code></li>
</ul>

<p>该 token 用来在 TLS 引导的时候验证 API server 信息。</p>

<ul>
  <li><code class="highlighter-rouge">--token=&lt;token&gt;</code></li>
</ul>

<p>多数情况下 <code class="highlighter-rouge">--discovery-token</code> 和 <code class="highlighter-rouge">--tls-bootstrap-token</code> 都使用同一个 token。这个选项就是给这两者指定同一个 token。如果提供其它选项则会覆盖这个选项。</p>

<h2 id="config-file">通过配置文件使用 kubeadm</h2>

<p><strong>警告：</strong> 目前 kubeadm 的命令行接口处于 beta 阶段，所以配置文件目前仍然处于 alpha 阶段并且在以后的版本中可能会出现改动。</p>

<p>可以用配置文件而不是命令来配置 kubeadm 行标志，一些更高级的功能可能只作为配置文件选项。在 <code class="highlighter-rouge">kubeadm init</code> 和 <code class="highlighter-rouge">kubeadm join</code> 上，这个文件通过 <code class="highlighter-rouge">--config</code> 选项传入。</p>

<h3 id="master-配置示例">Master 配置示例</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubeadm.k8s.io/v1alpha1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">MasterConfiguration</span>
<span class="na">api</span><span class="pi">:</span>
  <span class="na">advertiseAddress</span><span class="pi">:</span> <span class="s">&lt;address|string&gt;</span>
  <span class="na">bindPort</span><span class="pi">:</span> <span class="s">&lt;int&gt;</span>
<span class="na">etcd</span><span class="pi">:</span>
  <span class="na">endpoints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">&lt;endpoint1|string&gt;</span>
  <span class="pi">-</span> <span class="s">&lt;endpoint2|string&gt;</span>
  <span class="na">caFile</span><span class="pi">:</span> <span class="s">&lt;path|string&gt;</span>
  <span class="na">certFile</span><span class="pi">:</span> <span class="s">&lt;path|string&gt;</span>
  <span class="na">keyFile</span><span class="pi">:</span> <span class="s">&lt;path|string&gt;</span>
<span class="na">networking</span><span class="pi">:</span>
  <span class="na">dnsDomain</span><span class="pi">:</span> <span class="s">&lt;string&gt;</span>
  <span class="na">serviceSubnet</span><span class="pi">:</span> <span class="s">&lt;cidr&gt;</span>
  <span class="na">podSubnet</span><span class="pi">:</span> <span class="s">&lt;cidr&gt;</span>
<span class="na">kubernetesVersion</span><span class="pi">:</span> <span class="s">&lt;string&gt;</span>
<span class="na">cloudProvider</span><span class="pi">:</span> <span class="s">&lt;string&gt;</span>
<span class="na">authorizationModes</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">&lt;authorizationMode1|string&gt;</span>
<span class="pi">-</span> <span class="s">&lt;authorizationMode2|string&gt;</span>
<span class="na">token</span><span class="pi">:</span> <span class="s">&lt;string&gt;</span>
<span class="na">tokenTTL</span><span class="pi">:</span> <span class="s">&lt;time duration&gt;</span>
<span class="na">selfHosted</span><span class="pi">:</span> <span class="s">&lt;bool&gt;</span>
<span class="na">apiServerExtraArgs</span><span class="pi">:</span>
  <span class="s">&lt;argument&gt;</span><span class="pi">:</span> <span class="s">&lt;value|string&gt;</span>
  <span class="s">&lt;argument&gt;</span><span class="pi">:</span> <span class="s">&lt;value|string&gt;</span>
<span class="na">controllerManagerExtraArgs</span><span class="pi">:</span>
  <span class="s">&lt;argument&gt;</span><span class="pi">:</span> <span class="s">&lt;value|string&gt;</span>
  <span class="s">&lt;argument&gt;</span><span class="pi">:</span> <span class="s">&lt;value|string&gt;</span>
<span class="na">schedulerExtraArgs</span><span class="pi">:</span>
  <span class="s">&lt;argument&gt;</span><span class="pi">:</span> <span class="s">&lt;value|string&gt;</span>
  <span class="s">&lt;argument&gt;</span><span class="pi">:</span> <span class="s">&lt;value|string&gt;</span>
<span class="na">apiServerCertSANs</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">&lt;name1|string&gt;</span>
<span class="pi">-</span> <span class="s">&lt;name2|string&gt;</span>
<span class="na">certificatesDir</span><span class="pi">:</span> <span class="s">&lt;string&gt;</span>
</code></pre></div></div>

<p>另外，如果 authorizationMode 设置为 <code class="highlighter-rouge">ABAC</code>，那么您应该在 <code class="highlighter-rouge">/etc/kubernetes/abac_policy.json</code> 编写配置文件。
但是，如果 authorizationMode 设置为 <code class="highlighter-rouge">Webhook</code>，那么您应该在 <code class="highlighter-rouge">/etc/kubernetes/webhook_authz.conf</code> 编写配置文件。</p>

<h3 id="node-配置示例">Node 配置示例</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubeadm.k8s.io/v1alpha1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">NodeConfiguration</span>
<span class="na">caCertPath</span><span class="pi">:</span> <span class="s">&lt;path|string&gt;</span>
<span class="na">discoveryFile</span><span class="pi">:</span> <span class="s">&lt;path|string&gt;</span>
<span class="na">discoveryToken</span><span class="pi">:</span> <span class="s">&lt;string&gt;</span>
<span class="na">discoveryTokenAPIServers</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">&lt;address|string&gt;</span>
<span class="pi">-</span> <span class="s">&lt;address|string&gt;</span>
<span class="na">tlsBootstrapToken</span><span class="pi">:</span> <span class="s">&lt;string&gt;</span>
</code></pre></div></div>

<h2 id="更安全的安装">更安全的安装</h2>

<p>kubeadm 的默认设置可能不适用于所有人。本节介绍如何定制 kubeadm 的安装，这可能会导致一些可用性的损失。</p>

<h3 id="关闭-node-客户端证书的自动批准">关闭 Node 客户端证书的自动批准</h3>

<p>默认情况下，CSR 自动批准是启用状态，当使用 Bootstrap Token 进行身份验证时，基本上批准任何对于 kubelet 客户端证书的请求。如果您不希望集群自动批准 kubelet 客户端证书，您可以通过执行以下命令关闭它：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl delete clusterrole kubeadm:node-autoapprove-bootstrap
</code></pre></div></div>

<p>之后，<code class="highlighter-rouge">kubeadm join</code> 将被阻止，直到管理员手动批准了在等待批准的 CSR：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl get csr
<span class="go">NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   18s       system:bootstrap:878f07   Pending

</span><span class="gp">$</span> kubectl certificate approve node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ
<span class="go">certificatesigningrequest "node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ" approved

</span><span class="gp">$</span> kubectl get csr
<span class="go">NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   1m        system:bootstrap:878f07   Approved,Issued
</span></code></pre></div></div>

<p>只有在运行 <code class="highlighter-rouge">kubectl certificate approve</code> 之后，<code class="highlighter-rouge">kubeadm join</code> 才能继续执行。</p>

<h3 id="关闭集群信息-configmap-的公开访问">关闭集群信息 ConfigMap 的公开访问</h3>

<p>为了使用 token 作为唯一验证信息来实现 join 流程，默认情况下会公开一个具有验证 master 身份所需数据的公共 ConfigMap。 虽然 ConfigMap 中没有私人数据，但有些用户是敏感的，不管怎样都希望将其关闭。这样做会禁用 <code class="highlighter-rouge">kubeadm join</code> 过程中的 <code class="highlighter-rouge">--discovery-token</code> 选项。以下是实现的步骤：</p>

<p>从 API server 抓取 <code class="highlighter-rouge">集群信息</code> 文件：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl <span class="nt">-n</span> kube-public get cm cluster-info <span class="nt">-oyaml</span> | <span class="nb">grep</span> <span class="s2">"kubeconfig:"</span> <span class="nt">-A11</span> | <span class="nb">grep</span> <span class="s2">"apiVersion"</span> <span class="nt">-A10</span> | sed <span class="s2">"s/    //"</span> | tee cluster-info.yaml
<span class="go">apiVersion: v1
clusters:
- cluster:
</span><span class="gp">    certificate-authority-data: &lt;ca-cert&gt;</span>
<span class="gp">    server: https://&lt;ip&gt;</span>:&lt;port&gt;
<span class="go">  name: ""
contexts: []
current-context: ""
kind: Config
preferences: {}
users: []
</span></code></pre></div></div>

<p>然后您可以使用这个 <code class="highlighter-rouge">cluster-info.yaml</code> 文件作为 <code class="highlighter-rouge">kubeadm join --discovery-file</code> 的参数。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl <span class="nt">-n</span> kube-public delete rolebinding kubeadm:bootstrap-signer-clusterinfo
</code></pre></div></div>

<p>这些命令应该在 <code class="highlighter-rouge">kubeadm join</code> 之前 <code class="highlighter-rouge">kubeadm init</code> 之后运行。</p>

<h2 id="manage-tokens">管理 Token</h2>

<p>您可以使用 <code class="highlighter-rouge">kubeadm</code> 工具管理正在运行在集群上的令牌。它会自动从 <code class="highlighter-rouge">kubeadm</code> 创建的集群获取 master 的默认管理员凭证（<code class="highlighter-rouge">/etc/kubernetes/admin.conf</code>）。您可以使用 <code class="highlighter-rouge">--kubeconfig</code> 为以下命令指定备用 kubeconfig 文件以获取凭证。</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">kubeadm token list</code> 列出令牌和它们何时到期以及批准的用法。</p>
  </li>
  <li><code class="highlighter-rouge">kubeadm token create</code> 创建一个新的 token。
    <ul>
      <li><code class="highlighter-rouge">--description</code> 给新的 token 设置描述。</li>
      <li><code class="highlighter-rouge">--ttl duration</code> 从 “现在” 开始计时，以增量的方式给 token 设置到期时间。默认为0，表示永不过期。时间单位是秒。</li>
      <li><code class="highlighter-rouge">--usages</code> 设置 token 能够被使用的方式。默认是 <code class="highlighter-rouge">signing,authentication</code>。 这些使用方式已在上述章节列出。</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">kubeadm token delete &lt;token id&gt;|&lt;token id&gt;.&lt;token secret&gt;</code> 删除一个 token。这个 token 可以只使用 ID 也可以使用整个 token 值作为身份标识。只有 ID 被使用；如果 secret 不匹配 token 依然会被删除。</li>
</ul>

<p>另外，您可以使用 <code class="highlighter-rouge">kubeadm token generate</code> 命令在本地创建一个新的 token。这个 token 是用 <code class="highlighter-rouge">kubeadm init</code> 中 <code class="highlighter-rouge">--token</code> 参数的正确形式。</p>

<p>有关 token 是如何实现的（也包括在 kubeadm 之外管理它们），请参阅 <a href="/docs/admin/bootstrap-tokens/">Bootstrap Token 文档</a>。</p>

<h3 id="自动化-kubeadm">自动化 kubeadm</h3>

<p>您可以将令牌分发并行化，以实现更简单的自动化，而不是像在 <a href="/docs/admin/kubeadm/">kubeadm 基础教程</a> 中那样将从 <code class="highlighter-rouge">kubeadm init</code> 获得的令牌复制到每个节点。 要实现这种自动化，您必须知道 master 启动后的 IP 地址。</p>

<ol>
  <li>
    <p>生成一个 token。这个 token 必须满足格式 <code class="highlighter-rouge">&lt;6 character string&gt;.&lt;16 character string&gt;</code>。更正式地，它必须匹配正则表达式：
<code class="highlighter-rouge">[a-z0-9]{6}\.[a-z0-9]{16}</code>.</p>

    <p>kubeadm 可以为您生成这样的一个 token：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubeadm token generate
</code></pre></div>    </div>
  </li>
  <li>
    <p>使用此令牌同时启动 master 和 node 节点。当他们启动后，他们应该能够找到彼此并形成集群。在 <code class="highlighter-rouge">kubeadm init</code> 和 kubeadm join<code class="highlighter-rouge"> 上都可以使用相同的 </code>–token` 参数。</p>
  </li>
</ol>

<p>集群启动后，您可以从 master 节点的 <code class="highlighter-rouge">/etc/kubernetes/admin.conf</code> 获取管理凭证，并用它来与集群进行通信。</p>

<p>在其它 CRI 运行时（runtime）上使用 kubeadm</p>

<p>从 <a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG.md#node-components-1">Kubernetes 1.6 release</a> 版本开始，Kubernetes 容器运行时已经默认转移到使用 CRI 上了。目前，内置的容器运行时是 Docker，通过 <code class="highlighter-rouge">kubelet</code> 中内置的 <code class="highlighter-rouge">dockershim</code> 来启用。</p>

<p>在 kubeadm 中使用其他基于 CRI 的运行时非常简单，目前支持的运行时为：</p>

<ul>
  <li><a href="https://github.com/kubernetes-incubator/cri-o">cri-o</a></li>
  <li><a href="https://github.com/kubernetes/frakti">frakti</a></li>
  <li><a href="https://github.com/kubernetes-incubator/rktlet">rkt</a></li>
</ul>

<p>成功安装 <code class="highlighter-rouge">kubeadm</code> 和 <code class="highlighter-rouge">kubelet</code> 后，请按照以下两个步骤操作：</p>

<ol>
  <li>
    <p>在每个节点上安装运行时 shim（runtime shim）。您可以按照上面的运行时 shim 项目列表中的安装文档进行安装。</p>
  </li>
  <li>
    <p>配置 kubelet 来使用远程 CRI 运行时。记得修改 <code class="highlighter-rouge">RUNTIME_ENDPOINT</code> 为您的自定义值，例如 <code class="highlighter-rouge">/var/run/{your_runtime}.sock</code>:</p>
  </li>
</ol>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span><span class="nb">cat</span> <span class="o">&gt;</span> /etc/systemd/system/kubelet.service.d/20-cri.conf <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
Environment="KUBELET_EXTRA_ARGS=--container-runtime=remote --container-runtime-endpoint=</span><span class="nv">$RUNTIME_ENDPOINT</span><span class="sh"> --feature-gates=AllAlpha=true"
</span><span class="no">EOF
</span>  <span class="nv">$ </span>systemctl daemon-reload
</code></pre></div></div>

<p>这样 <code class="highlighter-rouge">kubelet</code> 就能够使用指定的 CRI 运行时了，然后您就可以继续 <code class="highlighter-rouge">kubeadm init</code> 和 <code class="highlighter-rouge">kubeadm join</code> 流程来部署 Kubernetes 集群。</p>

<h2 id="没有互联网连接的情况下运行-kubeadm">没有互联网连接的情况下运行 kubeadm</h2>

<p>所有的控制平面组件运行在由 kubelet 启动的 Pod 上，并且下面的镜像对于集群工作是必需的，当 <code class="highlighter-rouge">kubeadm init</code> 正在初始化您的 master 时，如果这些镜像在本地不存在，那么 kubelet 将会自动去拉取：</p>

<table>
  <thead>
    <tr>
      <th>镜像名称</th>
      <th>v1.6 release 分之版本</th>
      <th>v1.7 release 分支版本</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>gcr.io/google_containers/kube-apiserver-${ARCH}</td>
      <td>v1.6.x</td>
      <td>v1.7.x</td>
    </tr>
    <tr>
      <td>gcr.io/google_containers/kube-controller-manager-${ARCH}</td>
      <td>v1.6.x</td>
      <td>v1.7.x</td>
    </tr>
    <tr>
      <td>gcr.io/google_containers/kube-scheduler-${ARCH}</td>
      <td>v1.6.x</td>
      <td>v1.7.x</td>
    </tr>
    <tr>
      <td>gcr.io/google_containers/kube-proxy-${ARCH}</td>
      <td>v1.6.x</td>
      <td>v1.7.x</td>
    </tr>
    <tr>
      <td>gcr.io/google_containers/etcd-${ARCH}</td>
      <td>3.0.17</td>
      <td>3.0.17</td>
    </tr>
    <tr>
      <td>gcr.io/google_containers/pause-${ARCH}</td>
      <td>3.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <td>gcr.io/google_containers/k8s-dns-sidecar-${ARCH}</td>
      <td>1.14.1</td>
      <td>1.14.4</td>
    </tr>
    <tr>
      <td>gcr.io/google_containers/k8s-dns-kube-dns-${ARCH}</td>
      <td>1.14.1</td>
      <td>1.14.4</td>
    </tr>
    <tr>
      <td>gcr.io/google_containers/k8s-dns-dnsmasq-nanny-${ARCH}</td>
      <td>1.14.1</td>
      <td>1.14.4</td>
    </tr>
  </tbody>
</table>

<p>这里的 <code class="highlighter-rouge">v1.7.x</code> 表示 “v1.7 分支的最新补丁版本”。</p>

<p><code class="highlighter-rouge">${ARCH}</code> 可以是这些值之一：<code class="highlighter-rouge">amd64</code>, <code class="highlighter-rouge">arm</code>, <code class="highlighter-rouge">arm64</code>, <code class="highlighter-rouge">ppc64le</code> 或者 <code class="highlighter-rouge">s390x</code>。</p>

<h2 id="管理-kubeadm-中用于配置-kubelet-的插入文件">管理 kubeadm 中用于配置 kubelet 的插入文件</h2>

<p>kubeadm 包中包含用于配置 kubelet 如何运行的配置文件。需要注意的是，<code class="highlighter-rouge">kubeadm</code> CLI 命令永远不会涉及到这个插入文件（drop-in file）。这个插入文件属于 kubeadm deb/rpm 包。</p>

<p>这是在 v1.7 版本中的样子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Service]
Environment="KUBELET_KUBECONFIG_ARGS=--kubeconfig=/etc/kubernetes/kubelet.conf --require-kubeconfig=true"
Environment="KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true"
Environment="KUBELET_NETWORK_ARGS=--network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin"
Environment="KUBELET_DNS_ARGS=--cluster-dns=10.96.0.10 --cluster-domain=cluster.local"
Environment="KUBELET_AUTHZ_ARGS=--authorization-mode=Webhook --client-ca-file=/etc/kubernetes/pki/ca.crt"
Environment="KUBELET_CADVISOR_ARGS=--cadvisor-port=0"
ExecStart=
ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_SYSTEM_PODS_ARGS $KUBELET_NETWORK_ARGS $KUBELET_DNS_ARGS $KUBELET_AUTHZ_ARGS $KUBELET_CADVISOR_ARGS $KUBELET_EXTRA_ARGS
</code></pre></div></div>

<p>以下是详细分解：</p>

<ul>
  <li><code class="highlighter-rouge">--kubeconfig=/etc/kubernetes/kubelet.conf</code> 指向 kubeconfig 文件，以告诉 kubelet API server 的地址。这个文件也包含了 kubelet 的证书。</li>
  <li><code class="highlighter-rouge">--require-kubeconfig=true</code> 如果 kubeconfig 文件不存在那么 kubelet 将会立即失败。这将导致 kubelet 服务在启动后出现重复崩溃，直到运行了 <code class="highlighter-rouge">kubeadm init</code>。</li>
  <li><code class="highlighter-rouge">--pod-manifest-path=/etc/kubernetes/manifests</code> 指定从哪里读取静态 Pod 的 manifest 文件，这些静态 Pod 是用来启动控制平面的</li>
  <li><code class="highlighter-rouge">--allow-privileged=true</code> 允许 kubelet 运行特权 Pod（privileged Pods）</li>
  <li><code class="highlighter-rouge">--network-plugin=cni</code> 使用 CNI 网络</li>
  <li>
    <p><code class="highlighter-rouge">--cni-conf-dir=/etc/cni/net.d</code> 指定在哪里查找 <a href="https://github.com/containernetworking/cni/blob/master/SPEC.md">CNI spec 文件</a></p>
  </li>
  <li><code class="highlighter-rouge">--cni-bin-dir=/opt/cni/bin</code> 指定在哪里查找真正的 CNI 二进制文件</li>
  <li><code class="highlighter-rouge">--cluster-dns=10.96.0.10</code> 在 Pod 的 <code class="highlighter-rouge">/etc/resolv.conf</code> 中使用这个集群内部的 DNS 服务来作为 <code class="highlighter-rouge">nameserver</code> 入口</li>
  <li><code class="highlighter-rouge">--cluster-domain=cluster.local</code> 在 Pod 的 <code class="highlighter-rouge">/etc/resolv.conf</code> 中使用这个集群内部的 DNS 域来作为 <code class="highlighter-rouge">search</code> 入口</li>
  <li><code class="highlighter-rouge">--client-ca-file=/etc/kubernetes/pki/ca.crt</code> 使用此 CA 证书来验证对 Kubelet API 的请求</li>
  <li><code class="highlighter-rouge">--authorization-mode=Webhook</code> 验证对 Kubelet API 的请求，该请求通过向 API server <code class="highlighter-rouge">POST</code> 一个 <code class="highlighter-rouge">SubjectAccessReview</code> 来实现对 Kubelet API 的请求</li>
  <li>
    <p><code class="highlighter-rouge">--cadvisor-port=0</code> 将禁用 cAdvisor 监听 <code class="highlighter-rouge">0.0.0.0:4194</code> 的默认行为。cAdvisor 将继续运行在 kubelet 内部并且能够通过 <code class="highlighter-rouge">https://{node-ip}:10250/stats/</code> 访问它的 API。如果您想要 cAdvisor 监听更多的端口，请运行：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> sed -e "/cadvisor-port=0/d" -i /etc/systemd/system/kubelet.service.d/10-kubeadm.conf
 systemctl daemon-reload
 systemctl restart kubelet
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="集成云提供商实验性">集成云提供商（实验性）</h2>

<p>启用特定的云提供商是一个常见的要求。目前这需要手动配置，因此还没有完全支持。如果您想这样做，请在所有节点（包括 master 节点）上编辑 kubelet 服务的 kubeadm 插入（drop-in）文件(<code class="highlighter-rouge">/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code>)。如果您的云提供商需要在主机上安装任何额外的软件包（例如为了卷的安装和卸载），请安装这些软件包。</p>

<p>为 kubelet 指定 <code class="highlighter-rouge">--cloud-provider</code> 参数，并将其设置为您选择的云。如果您的云提供商需要配置文件，请在每个节点上创建文件 <code class="highlighter-rouge">/etc/kubernetes/cloud-config</code>。 该文件的确切格式和内容取决于您的云提供商施加的要求。如果使用 <code class="highlighter-rouge">/etc/kubernetes/cloud-config</code> 文件，则必须将其附加到 kubelet 参数中，如：<code class="highlighter-rouge">--cloud-config=/etc/kubernetes/cloud-config</code></p>

<p>请注意，目前很可能存在没有记录在案的其他提供商的个性配置（例如 AWS 的 IAM 角色）。</p>

<p>接下来，在 kubeadm 配置文件中指定云提供商。使用以下内容创建一个名为 <code class="highlighter-rouge">kubeadm.conf</code> 的文件：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">kind</span><span class="pi">:</span> <span class="s">MasterConfiguration</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubeadm.k8s.io/v1alpha1</span>
<span class="na">cloudProvider</span><span class="pi">:</span> <span class="s">&lt;cloud provider&gt;</span>
</code></pre></div></div>

<p>最后，运行 <code class="highlighter-rouge">kubeadm init --config = kubeadm.conf</code> 来引导云提供商的集群。</p>

<p>这个工作流程还没有完全支持，但是我们希望将来可以非常容易地与云提供商建立集群，有关详细信息，请参阅 <a href="https://github.com/kubernetes/community/pull/128">本提案</a>。<a href="https://github.com/kubernetes/kubernetes/pull/29459">Kubelet 动态设置</a> 特性也可能有助于将来完全自动化这个流程。</p>

<h2 id="环境变量">环境变量</h2>

<p>有一些环境变量可以修改 kubeadm 的工作方式。大多数用户将不需要设置这些环境变量。这些环境变量是一个短期的解决方案，最终它们将被集成到 kubeadm 配置文件中。</p>

<p><strong>注意：</strong> 这些环境变量已被弃用，并将在 v1.8 停止运作！</p>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>默认值</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">KUBE_KUBERNETES_DIR</code></td>
      <td><code class="highlighter-rouge">/etc/kubernetes</code></td>
      <td>大部分配置文件写入和读取的位置</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">KUBE_HYPERKUBE_IMAGE</code></td>
      <td> </td>
      <td>如果设置，使用具有此名称的单个 hyperkube 镜像。如果未设置，则将使用每个服务器组件的单个镜像。</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">KUBE_ETCD_IMAGE</code></td>
      <td><code class="highlighter-rouge">gcr.io/google_containers/etcd-&lt;arch&gt;:3.0.17</code></td>
      <td>将要使用的 etcd 容器镜像。</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">KUBE_REPO_PREFIX</code></td>
      <td><code class="highlighter-rouge">gcr.io/google_containers</code></td>
      <td>使用的所有镜像的前缀。</td>
    </tr>
  </tbody>
</table>

<p>如果指定了 <code class="highlighter-rouge">KUBE_KUBERNETES_DIR</code>，则可能需要重写 kubelet 的参数（例如 –kubeconfig，–pod-manifest-path）。</p>

<p>如果指定了 <code class="highlighter-rouge">KUBE_REPO_PREFIX</code>，则可能需要将设置 kubelet 的参数 <code class="highlighter-rouge">--pod-infra-container-image</code>，该参数指定要使用哪个 pause 镜像。</p>

<p><code class="highlighter-rouge">gcr.io/google_containers/pause-${ARCH}:3.0</code> 中的 <code class="highlighter-rouge">${ARCH}</code> 的默认值可以是 <code class="highlighter-rouge">amd64</code>、<code class="highlighter-rouge">arm</code>、<code class="highlighter-rouge">arm64</code>、<code class="highlighter-rouge">ppc64le</code> 或者 <code class="highlighter-rouge">s390x</code> 中的一个。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /etc/systemd/system/kubelet.service.d/20-pod-infra-image.conf <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
[Service]
Environment="KUBELET_EXTRA_ARGS=--pod-infra-container-image=&lt;your-image&gt;"
</span><span class="no">EOF
</span>systemctl daemon-reload
systemctl restart kubelet
</code></pre></div></div>

<p>如果要通过 http 代理使用 kubeadm，则可能需要将其配置为支持 http_proxy，https_proxy 或 no_proxy。</p>

<p>例如，如果您的kube master 节点 IP 地址为 10.18.17.16，并且您有一个同时支持 10.18.17.16 上 8080 端口上的 http/https 的代理，则可以使用以下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">PROXY_PORT</span><span class="o">=</span>8080
<span class="nb">export </span><span class="nv">PROXY_IP</span><span class="o">=</span>10.18.17.16
<span class="nb">export </span><span class="nv">http_proxy</span><span class="o">=</span>http://<span class="nv">$PROXY_IP</span>:<span class="nv">$PROXY_PORT</span>
<span class="nb">export </span><span class="nv">HTTP_PROXY</span><span class="o">=</span><span class="nv">$http_proxy</span>
<span class="nb">export </span><span class="nv">https_proxy</span><span class="o">=</span><span class="nv">$http_proxy</span>
<span class="nb">export </span><span class="nv">HTTPS_PROXY</span><span class="o">=</span><span class="nv">$http_proxy</span>
<span class="nb">export </span><span class="nv">no_proxy</span><span class="o">=</span><span class="s2">"localhost,127.0.0.1,localaddress,.localdomain.com,example.com,10.18.17.16"</span>
</code></pre></div></div>

<p>请记得修改 <code class="highlighter-rouge">proxy_ip</code> 并将 kube master 节点 IP 地址添加到 <code class="highlighter-rouge">no_proxy</code>。</p>

<h2 id="使用自定义证书">使用自定义证书</h2>

<p>默认情况下，kubeadm 将生成集群运行所需的所有证书。您可以通过提供自己的证书来覆盖此行为。</p>

<p>为此，您必须将它们放置在 <code class="highlighter-rouge">--cert-dir</code> 参数或 <code class="highlighter-rouge">CertificatesDir</code> 配置文件密钥所指定的目录中。默认目录为 <code class="highlighter-rouge">/etc/kubernetes/pki</code>。</p>

<p>如果给定的证书和私钥对都存在，kubeadm 会跳过生成步骤，这些文件将被验证并用于规定的用例。</p>

<p>这意味着你可以用一个现有的 CA 预填充 <code class="highlighter-rouge">/etc/kubernetes/pki/ca.crt</code> 和 <code class="highlighter-rouge">/etc/kubernetes/pki/ca.key</code>，然后用它来签署其余的证书。</p>

<h2 id="发布版本和发布须知">发布版本和发布须知</h2>

<p>如果你已经安装了 kubeadm 并想升级，运行 <code class="highlighter-rouge">apt-get update &amp;&amp; apt-get upgrade</code> 或者 <code class="highlighter-rouge">yum update</code> 来获取最新版本的 kubeadm。</p>

<p>参阅 <a href="https://git.k8s.io/kubeadm/CHANGELOG.md">CHANGELOG.md</a> 来获得更多信息。</p>


        <p><a href=""><img src="https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/docs/admin/kubeadm.md?pixel" alt="Analytics" /></a></p>
        
        
        <script type="text/javascript">
            PDRTJS_settings_8345992 = {
                "id" : "8345992",
                "unique_id" : "/docs/admin/kubeadm/",
                "title" : "kubeadm 设置工具参考指南",
                "permalink" : "https://kubernetes.io/docs/admin/kubeadm/"
            };
            (function(d,c,j){if(!document.getElementById(j)){var pd=d.createElement(c),s;pd.id=j;pd.src=('https:'==document.location.protocol)?'https://polldaddy.com/js/rating/rating.js':'http://i0.poll.fm/js/rating/rating.js';s=document.getElementsByTagName(c)[0];s.parentNode.insertBefore(pd,s);}}(document,'script','pd-rating-js'));
        </script>
        <a href="" onclick="window.open('https://github.com/kubernetes/website/issues/new?title=Issue%20with%20' +
        'k8s.io'+window.location.pathname)" class="button issue">Create an Issue</a>
        
        
          <a href="/editdocs#docs/admin/kubeadm.md" class="button issue">Edit this Page</a>
        
    
    </div>
</section>

<footer>
    <main class="light-text">
        <nav>
            <a href="/docs/tutorials/stateless-application/hello-minikube/">Get Started</a>
            <a href="/docs/home/">Documentation</a>
            <a href="http://blog.kubernetes.io/">Blog</a>
            <a href="/partners/">Partners</a>
            <a href="/community/">Community</a>
            <a href="/case-studies/">Case Studies</a>
        </nav>
        <div class="social">
            <div>
                <a href="https://twitter.com/kubernetesio" class="twitter"><span>twitter</span></a>
                <a href="https://github.com/kubernetes/kubernetes" class="github"><span>Github</span></a>
                <a href="http://slack.k8s.io/" class="slack"><span>Slack</span></a>
            </div>
            <div>
                <a href="http://stackoverflow.com/questions/tagged/kubernetes" class="stack-overflow"><span>Stack Overflow</span></a>
                <a href="https://groups.google.com/forum/#!forum/kubernetes-users" class="mailing-list"><span>Mailing List</span></a>
                <a href="https://calendar.google.com/calendar/embed?src=nt2tcnbtbied3l6gi2h29slvc0%40group.calendar.google.com" class="calendar"><span>Events Calendar</span></a>
            </div>
            <div>
                <a href="/docs/setup/pick-right-solution/" class="button">Get Kubernetes</a>
                <a href="https://github.com/kubernetes/kubernetes" class="button">Contribute</a>
            </div>
        </div>
        <div id="miceType" class="center">
            &copy; 2018 The Kubernetes Authors | Documentation Distributed under <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a>
        </div>
        <div id="miceType" class="center">
            Copyright &copy; 2018 The Linux Foundation&reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">Trademark Usage page</a>
        </div>
    </main>
</footer>

<button class="flyout-button" onclick="kub.toggleToc()"></button>

<style>
.cse .gsc-control-cse, .gsc-control-cse, {
    padding: 0;
}
  .gsc-control-cse table, .gsc-control-cse-en table {
      margin:0px !important;
  }
  .gsc-above-wrapper-area {
      border-bottom: 0;
  }
</style>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-36037335-10', 'auto');
ga('send', 'pageview');

// hide docs nav area if no nav is present, or if nav only contains a link to the current page
(function () {
    window.addEventListener('DOMContentLoaded', init)

        // play nice with our neighbors
        function init() {
            window.removeEventListener('DOMContentLoaded', init)
                hideNav()
        }

    function hideNav(toc){
        if (!toc) toc = document.querySelector('#docsToc')
        if (!toc) return
            var container = toc.querySelector('.container')

                // container is built dynamically, so it may not be present on the first runloop
                if (container) {
                    if (container.childElementCount === 0 || toc.querySelectorAll('a.item').length === 1) {
                        toc.style.display = 'none'
                            document.getElementById('docsContent').style.width = '100%'
                    }
                } else {
                    requestAnimationFrame(function () {
                        hideNav(toc)
                    })
                }
    }
})();
</script>

<!-- Commenting out AnswerDash for now; we need to work on our list of questions/answers/design first
    <!-- Start of AnswerDash script <script>var AnswerDash;!function(e,t,n,s,a){if(!t.getElementById(s)){var i,r=t.createElement(n),c=t.getElementsByTagName(n)[0];e[a]||(i=e[a]=function(){i.__oninit.push(arguments)},i.__oninit=[]),r.type="text/javascript",r.async=!0,r.src="https://p1.answerdash.com/answerdash.min.js?siteid=756",r.setAttribute("id",s),c.parentNode.insertBefore(r,c)}}(window,document,"script","answerdash-script","AnswerDash");</script> <!-- End of AnswerDash script -->


</body>
</html>
